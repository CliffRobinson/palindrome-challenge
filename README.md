# palindrome-challenge

This is for a tech test. The problem specification is: A palindrome number reads same both ways, example 91019, 112211. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99. Find the largest palindrome number made from the product of two 3-digit numbers.

I wrote this in NodeJS. I started by creating a validator function to check whether a given input is a palindrome (isThisAPalindrome or itap). Notably, it forces the input to behave as a string whether or not it's a number, and it can be important to specify because JS is duck-typed. 

Then I wrote tests for isThisAPalindrome, which is also the point where I needed to introduce node modules for testing. I tested strings and numbers, palindrome and non-palindrome, odd and even numbered, because the function has slightly different behaviour for odd and even numbers of characters in the input. 

Once I confirmed that isThisAPalindrome was working as intended, I started looking at how to make pairs of factors and their associated products. This ended up being the function createFactorPairs. The function takes a starting value (e.g. 99 to test all 2-digit numbers, or 999 for all 3-digit numbers), and outputs an array of factor pairs, sorted by size of the product of the pairs. All pairs should be unique, but some will produce identical products. This will never effect the final answer, but in order to make the behaviour predictable I wrote a secondary sort, so the factor pairs are sorted by product size, then first factor size. 

The factor pairs are created by a for-loop within a for loop. You can cut the time this takes in half by eliminating duplicate pairs (e.g 3-2 and 2-3) but it is still operating on quadratic time, so it is definitely the most inefficient part of the algorithm. Once the pairs are generated they are sorted using the default sorting algorithm, which I presume operates on logarithmic time. 

I wrote unit tests for generateFactorPairs to confirm that it creates all pairs for a small set (comparing it against a set of pairs I generated by hand).

Once that was done I confirmed that the programme gets the correct answer for 2-digits, and it does. For 3-digits it produces the answer 993 * 913 = 906609. For four digits it takes about a minute and a half to produce 9999 * 9901 = 99000099. As I write this I have it trying to calculate 5-digits. It's been about 30 minutes and I expect it will take another couple of hours to get the answer. (A quick hack suggests the answer to 5-digits is  99979*99681 = 996606699, but only checks factors higher that 90k, so it's not mathematically guaranteed to be the right answer). 

So it's not a perfect solution. If I was doing this at work, I would take this back to you and explain that I had found the answer but if efficiency is needed I would need to refactor. I'm still pretty happy with it as a first pass though. Apart from finding the answer, my goals were to make sure the code is legible and tested, which I think I achieved. 

The file allinone.js incorporates the entire logic of the programme, and should work anywhere Javascript works. NodeJS works by breaking the different functions (and their unit tests) into separate files, so the repo contains the both the separate files and allinone. This doubling handling introduces the possibility of errors, but at work this wouldn't come up because I would know what context my code was expected to run in,  whereas here I wanted to prioritise keeping it simple and easy to run in whatever way you prefer your JS. 
